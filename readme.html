<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>queuectl README</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            line-height: 1.6;
            max-width: 800px;
            margin: 2rem auto;
            padding: 2rem;
            color: #333;
        }
        h1, h2, h3 {
            border-bottom: 1px solid #eaecef;
            padding-bottom: 0.3em;
            margin-top: 24px;
            margin-bottom: 16px;
            font-weight: 600;
        }
        h1 { font-size: 2.25em; }
        h2 { font-size: 1.75em; }
        h3 { font-size: 1.25em; }
        pre {
            background-color: #f6f8fa;
            border-radius: 6px;
            padding: 16px;
            overflow: auto;
            font-size: 85%;
        }
        code {
            font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, monospace;
        }
        pre > code {
            font-size: 100%;
            padding: 0;
            margin: 0;
            background-color: transparent;
            border: 0;
        }
        code:not(pre > code) {
            background-color: #f6f8fa;
            border-radius: 3px;
            padding: 0.2em 0.4em;
            margin: 0;
        }
        ul, ol {
            padding-left: 2em;
        }
        li {
            margin-bottom: 0.5em;
        }
        p {
            margin-top: 0;
            margin-bottom: 16px;
        }
        a {
            color: #0366d6;
            text-decoration: none;
        }
        a:hover {
            text-decoration: underline;
        }
    </style>
</head>
<body>
    <h1><code>queuectl</code>: A Minimal, Production-Grade CLI Job Queue</h1>

    <p><code>queuectl</code> is a lightweight, persistent, and concurrent background job queue system built in Python. It uses SQLite for persistent storage, supports multiple parallel worker processes, and handles automatic retries with exponential backoff and a Dead Letter Queue (DLQ).</p>

    <p><em>(A working CLI demo (video) would be linked here.)</em></p>

    <h2>Architecture Overview</h2>

    <p><code>queuectl</code> is architected for robustness and simplicity, built on four main components:</p>

    <ol>
        <li><strong>Persistence Layer (<code>persistence.py</code>):</strong> Uses SQLite as a transactional, persistent backend. All database access is abstracted via a Repository pattern.</li>
        <li><strong>Core Logic (<code>core.py</code>):</strong> A State Machine that manages the job lifecycle (<code>pending</code>, <code>processing</code>, <code>completed</code>, <code>failed</code>, <code>dead</code>).</li>
        <li><strong>Execution Layer (<code>worker.py</code>):</strong> A <code>multiprocessing</code>-based worker system that fetches and executes jobs in parallel using <code>subprocess</code>.</li>
        <li><strong>Interface Layer (<code>cli.py</code>):</strong> A user-friendly CLI built with <code>rich-click</code> for all operations.</li>
    </ol>

    <h3>Job Lifecycle</h3>

    <p>Jobs transition through the following states:</p>

    <ol>
        <li><strong><code>pending</code></strong>: The initial state. The job is waiting for a worker.</li>
        <li><strong><code>processing</code></strong>: A worker has atomically dequeued the job and is executing it.</li>
        <li><strong><code>completed</code></strong>: The job's command exited with <code>returncode 0</code>.</li>
        <li><strong><code>failed</code></strong>: The job's command failed (non-zero exit) or timed out, but it still has retries left. It is rescheduled to <code>pending</code> with a <code>run_at</code> timestamp based on exponential backoff.</li>
        <li><strong><code>dead</code></strong>: The job failed and has exhausted all <code>max_retries</code>. It is now in the Dead Letter Queue (DLQ) and requires manual intervention (e.g., <code>queuectl requeue</code>).</li>
    </ol>

    <h3>Concurrency and Atomicity</h3>

    <p>The system is designed to be multi-process safe and prevent duplicate job execution. It achieves this using:</p>

    <ul>
        <li><strong>SQLite WAL Mode:</strong> The database is run in Write-Ahead Log (WAL) mode (<code>PRAGMA journal_mode=WAL;</code>), which allows for concurrent read/write access without "database is locked" errors.</li>
        <li><strong>Atomic Dequeue:</strong> Workers do <em>not</em> use a <code>SELECT</code> then <code>UPDATE</code> pattern. Instead, they use a single, atomic <code>UPDATE... RETURNING *</code> query to find, lock, and claim a job in one step, making race conditions impossible.</li>
    </ul>

    <h2>Setup Instructions</h2>

    <ol>
        <li>
            <p><strong>Clone the repository (or create the files):</strong></p>
            <p>Create the project structure as shown in the previous steps and copy/paste the code for each file.</p>
        </li>
        <li>
            <p><strong>Create and activate a virtual environment:</strong></p>
            <pre><code>python -m venv.venv
source.venv/bin/activate</code></pre>
        </li>
        <li>
            <p><strong>Install the package:</strong></p>
            <p>For development (editable mode):</p>
            <pre><code>pip install -e.</code></pre>
        </li>
        <li>
            <p><strong>Initialize the database:</strong></p>
            <p>Before first use, you must initialize the SQLite database:</p>
            <pre><code>queuectl initdb</code></pre>
            <p>This creates the <code>queue.db</code> file in the current directory.</p>
        </li>
    </ol>

    <h2>Usage Examples</h2>

    <p><code>queuectl</code> provides a <code>rich-click</code> CLI for all operations.</p>

    <h3>1. Add a new job</h3>
    <pre><code>$ queuectl add "echo 'Hello World'"
Job enqueued with ID: 1a7b...

# Add a job with max 5 retries
$ queuectl add "sleep 2" --max-retries 5

# Add a high-priority job
$ queuectl add "echo 'Urgent!'" --priority 10

# Add a job scheduled to run in the future
$ queuectl add "echo 'later'" --run-at "2025-12-01T10:00:00Z"</code></pre>

    <h3>2. List jobs</h3>
    <pre><code># List pending jobs (the default)
$ queuectl list

# List completed jobs
$ queuectl list --state completed

# List the Dead Letter Queue (DLQ)
$ queuectl list --dlq</code></pre>

    <h3>3. Run workers</h3>
    <pre><code># Start a single worker
$ queuectl worker

# Start 4 parallel worker processes
$ queuectl worker -n 4

# Start workers with a different backoff (3^attempts)
$ queuectl worker -n 4 --backoff-base 3</code></pre>
    <p><em>(Workers will print logs as they start, fetch, and complete jobs. Press <code>Ctrl+C</code> to initiate a graceful shutdown.)</em></p>

    <h3>4. Show job details (and output)</h3>
    <pre><code>$ queuectl show &lt;job-id&gt;</code></pre>

    <h3>5. Requeue a job from the DLQ</h3>
    <pre><code># Move a job from 'dead' back to 'pending'
$ queuectl requeue &lt;job-id-from-dlq&gt;</code></pre>

    <h2>Assumptions & Trade-offs</h2>

    <ol>
        <li><strong>Single-Host System:</strong> <code>queuectl</code> is designed as a <em>single-host</em> job queue. The SQLite database is a local file. It is <em>not</em> intended to be accessed over a network filesystem (NFS), which can lead to data corruption.</li>
        <li><strong><code>shell=True</code> Security:</strong> The <code>add</code> command accepts a command string, which is executed with <code>shell=True</code>. This is a security risk (command injection). A more secure design would require commands as a JSON list (e.g., <code>["echo", "hello"]</code>) and execute with <code>shell=False</code>.</li>
        <li><strong>WAL Write Serialization:</strong> While WAL mode allows concurrent reads, it serializes all <em>write</em> transactions. This architecture is robust, but it is not designed to compete with network brokers like Redis or RabbitMQ on raw, high-frequency write throughput.</li>
    </ol>

    <h2>Testing Instructions</h2>

    <p>This project uses <code>pytest</code>.</p>

    <ol>
        <li>
            <p><strong>Install testing dependencies:</strong></p>
            <pre><code>pip install pytest pytest-mock</code></pre>
        </li>
        <li>
            <p><strong>Run the full test suite:</strong></p>
            <pre><code>pytest</code></pre>
        </li>
    </ol>

</body>
</html>
